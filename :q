#include<stdio.h>
#include<stdint.h>
#include<stdlib.h>
#include<string.h>
#include<time.h>
#include<unistd.h>
#include"fin01.h"
#include"fin02.h"
void checkChoose(_player *player, int playNum) {
    system("clear");
    printf(NONE);
    int c = 0;
    char buffer[10] = {0};
    printf("選擇察看手牌或牌局\n(1)手牌\n(2)排局\n(3)兩者\n");
    scanf("%d", &c);
    switch(c) {
    case 1:
        printCard(&player[playNum - 1]);
        fgets(buffer, 10, stdin);
        break;
    case 2:
        printStatus(player, playNum);
        fgets(buffer, 10, stdin);
        break;
    case 3:
        printCard(&player[playNum - 1]);
        printf("按 ENTER 以繼續\n");
        fgets(buffer, 10, stdin);
        fgets(buffer, 10, stdin);
        printStatus(player, playNum);
        break;
    default:
        printf("無此選項\n");
        break;
    }
    printf("按 ENTER 以繼續\n");
    fgets(buffer, 10, stdin);
}
int buildPayment(_player *player, int order, int discount, int *pay) {
    card *pNode = player->cards.pNext;
    int id = -1;
    int t = 0;
    while(pNode) {
        ++t;
        if(t == order) {
            id = pNode->id - 1;
            break;
        }
        pNode = pNode->pNext;
    }
    *pay = cardType[id].pay - discount;
    if(*pay < 0) pay = 0;
    return id;
}
void Build(_player *player, int num, int id) {
    system("clear");
    player->buildings[player->numbers_of_buildings] = cardType[id].point;
    system("clear");
    printf(BROWN);
    printf("玩家%2d 建造 %s\n", num, cardType[id].ch_name);
    sleep(2);
}
void builder_action(_player *player, int playerNum, int privilege) {
    int i = 0;
    for(int ii = 1; ii <= 4; ++ii) {
        system("clear");
        int choose = 0;
        int discardArray[10] = {0};
        int pay = -10;
        int discount = 0;
        int id = 0;
        if(ii >= privilege) i = ii + privilege - 1;
        else i = ii + privilege - 1;
        if(i > 4) i -= 4;
        if(i == privilege) discount = 1;
        if(i == privilege && player[i - 1].specials.Library) discount = 2;
        if(i == playerNum) {
            printCard(&player[i - 1]);
            printf(BROWN"請選擇一個建築建造，或是輸入 -1 不建造\n");
            scanf("%d", &choose);
            if(choose > 0 && choose <= player[i - 1].number_of_cards) {
                id = buildPayment(&player[i - 1], choose, discount, &pay);
                if((player[i - 1].specials.Smithy && id < 5) || (player[i - 1].specials.Quarry && id >= 5)) {
                    --pay;
                    if(pay < 0) pay = 0;
                }
                if(pay < player[i - 1].number_of_cards) {
                    discard(&player[i - 1], choose);
                    int amount_of_cards = player[i - 1].number_of_cards - pay;
                    if(pay == 0) {
                        Build(&player[i - 1], i, id);
                    }
                    else if(amount_of_cards == 0) {
                        for(int j = 1; j <= pay; ++j) discard(&player[i - 1], 1);
                        Build(&player[i - 1], i, id);
                    }
                    else {
                        printCard(&player[i - 1]);
                        printf(BROWN"請選擇 %2d張牌丟棄\n", pay);
                        int j = 0;
                        while(1) {
                            scanf("%d", &discardArray[j]);
                            if(i != 0) {
                                if(discardArray[i - 1] < discardArray[i]) discard(&player[i - 1], discardArray[j] - 1);
                                else discard(&player[i - 1], discardArray[j]);
                            }
                            else discard(&player[i - 1], discardArray[j]);
                            if(player[i - 1].number_of_cards <= amount_of_cards) break;
                            ++j;
                        }
                        Build(&player[i - 1], i, id);
                    }
                    checkChoose(player, i);
                }
                else printf(BROWN"目前卡牌數量不足以支付該建築\n");
            }
            else if(choose == -1) printf(BROWN"玩家%2d 選擇不建造\n", i);
            else printf(BROWN"無此建築\n");
            sleep(2);
        }
        else {
            card *pCard = player[i - 1].cards.pNext;
            int id = -1;
            int choose = 0;
            while(pCard) {
                ++choose;
                id = pCard->id - 1;
                if(cardType[id].pay < player->number_of_cards) {
                    id = buildPayment(&player[i - 1], choose, discount, &pay);
                    if(player[i - 1].specials.Smithy && id < 5) {
                        --pay;
                        if(pay < 0) pay = 0;
                    }
                    discard(&player[i - 1], choose);
                    for(int j = 1; j <= pay; ++j) {
                        discardArray[j] = j;
                        discard(&player[i-1], discardArray[j]);
                    }
                    Build(&player[i - 1], i, id);
                }
                pCard = pCard->pNext;
            }
            if(pay == -10) printf(BROWN"玩家%2d 選擇不建造\n", i);
            sleep(2);
        }
        if(player[i - 1].specials.PoorHouse && choose != -1 && player[i - 1].number_of_cards <= 1 && pay >= 0) {
            addCard(&player[i - 1], cardHeap[heapIndex]);
            ++heapIndex;
        }
        if(player[i - 1].specials.Carpenter && pay >= 0) {
            addCard(&player[i - 1], cardHeap[heapIndex]);
            ++heapIndex;
        }
    }
    printf(NONE);
}
void builder_privilege();
void producer_action(_player * player, int playerNum, int privilege) {}
void producer_privilege();
void trader_action(_player * player, int playerNum, int privilege) {}
void trader_privilege();
void councillor_action(_player * player, int playerNum, int privilege) {}
void councillor_privilege();
void prospector_action(_player * player, int playerNum, int privilege) {}
void prospector_privilege();
int main() {
    cardRander();
    heapIndex = 0;//代表現在抽到第幾張
    _player player[4];
    memset(player, 0x00, sizeof(player));
    for(int i = 0; i < 4; ++i) {
        player[i].id = i;
        player[i].buildings[0] = 1;
        player[i].numbers_of_buildings = 1;
        player[i].point = 1;
        player[i].cards.id = 0;
        player[i].cards.pNext = NULL;
        for(int j = 0; j < 4; ++j) {
            addCard(&player[i], cardHeap[heapIndex]);
            ++heapIndex;
        }
        player[i].card_limit = 4;
        player[i].role = 0;
        player[i].pNext = NULL;
    }//初始化四個玩家的struct
    system("clear");
    int level = 0;
    while(level > 2 || level < 1) {
        printf("選擇遊戲等級\n(1)level 1\n(2)level 2\n");
        scanf("%d", &level);
    }
    system("clear");
    int playerNum = 0;
    printf("選擇玩家號碼:\n(1)玩家 1\n(2)玩家 2\n(3)玩家 3\n(4)玩家 4\n(5)隨機\n");
    scanf("%d", &playerNum);
    if(playerNum == 5) {
        srand(time(0));
        playerNum = rand() % 4 + 1;
    }
    system("clear");
    /*printStatus(player, playerNum);
    printCard(&player[playerNum - 1]);
    for(int i = 0; i < 4; ++i) {
        if(i + 1 != playerNum) computerDicard(&player[i]);
        else playerDiscard(&player[i]);
    }
    system("clear");*/
    /*printStatus(player, playerNum);
    printCard(&player[playerNum - 1]);
    char buffer[10] = {0};
    printf("按 ENTER 以繼續\n");
    fgets(buffer, 10, stdin);
    fgets(buffer, 10, stdin);*/
    checkChoose(player, playerNum);
    for(int i = 0; i < 4; ++i) player[i].card_limit = 7;
    int governor = rand() % 4 + 1;
    int ii = 0;
    //for(int ii = 1; ii <= 4; ++ii) {
    while(1) {
        ii %= 4 + 1;
        int i = 0;
        int usedRole[5] = {0};
        if(ii >= governor) i = ii - governor + 1;
        else i = ii + governor - 1;
        system("clear");
        printf(BLUE"玩家 %d 是總督(從他開始)\n", governor);
        sleep(2);
        printf(NONE);
        for(int jj = 1; jj <= 4; ++jj) {
            int j = 0;
            int choose = 0;
            if(jj >= governor) j = jj + governor - 1;
            else j = jj + governor - 1;
            if(j > 4) j -= 4;
            if(j == playerNum) choose = playerChoose(usedRole);
            else choose = computerChooseRole(usedRole);
            system("clear");
            printf(GREEN"玩家%2d 選擇 %s\n", j, roles[choose - 1].name);
            sleep(2);
            printf(NONE);
            switch(choose) {
            case 1:
                builder_action(player, playerNum, j);
                break;
            case 2:
                producer_action(player, playerNum, j);
                break;
            case 3:
                trader_action(player, playerNum, j);
                break;
            case 4:
                councillor_action(player, playerNum, j);
                break;
            case 5:
                producer_action(player, playerNum, j);
                break;
            default:
                break;
            }
        }
        for(int j = 0; j < 4; ++j) {
            if(player[j].card_limit < player[j].number_of_cards) {
                if(j + 1 == playerNum) playerDiscard(&player[j]);
                else computerDicard(&player[j]);
            }
        }
        ++governor;
        ++ii;
        if(governor > 4) governor = 1;
    }
    return 0;
}
